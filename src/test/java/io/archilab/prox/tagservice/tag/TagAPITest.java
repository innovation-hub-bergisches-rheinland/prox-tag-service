package io.archilab.prox.tagservice.tag;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.AutoConfigureDataJpa;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

/**
 * These tests will test the controller mapping on /tags for basic CRUD functionality.
 * As the controllers are generated by Spring Data and an intense testing of them would end up
 * as testing the framework, the tests in this class should be considered as an integration test
 * between API and database.
 *
 * The test class excludes the Security Filter Chain and mocks the web service
 * Also it makes use of the DataJpa test to rollback transactions after each test
 */
@SpringBootTest
@AutoConfigureMockMvc(addFilters = false)
@AutoConfigureDataJpa
@Transactional
class TagAPITest {
  private static final String TAGS_ROUTE = "/tags";
  private static final String TAGS_ID_ROUTE = "/tags/{id}";


  @Autowired
  MockMvc mockMvc;

  @Autowired
  TagRepository tagRepository;

  //GET /tags
  @Test
  void when_get_tags_then_tags_found() throws Exception {
    List<Tag> savedTags = Arrays.asList(new Tag(new TagName("tag 1")), new Tag(new TagName("tag 2")));
    tagRepository.saveAll(savedTags);

    mockMvc.perform(get(TAGS_ROUTE))
        .andDo(print())
        .andExpect(status().isOk())
        .andExpect(jsonPath("$._embedded").exists())
        .andExpect(jsonPath("$._embedded.tags").exists())
        .andExpect(jsonPath("$._embedded.tags[0].id").exists())
        .andExpect(jsonPath("$._embedded.tags[0].tagName").value(savedTags.get(0).getTagName().getTagName().toLowerCase()))
        .andExpect(jsonPath("$._embedded.tags[1].id").exists())
        .andExpect(jsonPath("$._embedded.tags[1].tagName").value(savedTags.get(1).getTagName().getTagName().toLowerCase()));
  }

  //GET /tags/{id}
  @Test
  void when_get_tags_valid_id_then_tag_found() throws Exception {
    Tag tag = new Tag(new TagName("tag 1"));
    tagRepository.save(tag);

    mockMvc.perform(get(TAGS_ID_ROUTE, tag.getId()))
        .andDo(print())
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.id").exists())
        .andExpect(jsonPath("$.tagName").value(tag.getTagName().getTagName().toLowerCase()));
  }

  //GET /tags/{id}
  @Test
  void when_get_tags_invalid_id_then_not_found() throws Exception {
    Tag tag = new Tag(new TagName("tag 1"));
    tagRepository.save(tag);

    mockMvc.perform(get(TAGS_ID_ROUTE, UUID.randomUUID()))
        .andDo(print())
        .andExpect(status().isNotFound());
  }

  //DELETE /tags/{id}
  @Test
  void when_delete_tags_valid_id_then_no_content() throws Exception {
    Tag tag = new Tag(new TagName("tag 1"));
    tagRepository.save(tag);

    assertTrue(tagRepository.findById(tag.getId()).isPresent());

    mockMvc.perform(delete(TAGS_ID_ROUTE, tag.getId()))
        .andDo(print())
        .andExpect(status().isNoContent());

    assertTrue(tagRepository.findById(tag.getId()).isEmpty());
  }

  //POST /tags
  @Test
  void when_post_tags_then_is_created() throws Exception {
    Tag tag = new Tag(new TagName("tag 1"));

    mockMvc.perform(post(TAGS_ROUTE).contentType(MediaType.APPLICATION_JSON).content(new ObjectMapper().writeValueAsString(tag)))
        .andDo(print())
        .andExpect(status().isCreated());

    Optional<Tag> foundTag = tagRepository.findById(tag.getId());
    assertTrue(foundTag.isPresent());
    assertEquals(tag, foundTag.get());
  }

  //PUT /tags/{id}
  @Test
  void when_put_tags_then_is_updated() throws Exception {
    Tag tag = new Tag(new TagName("tag 1"));
    tagRepository.save(tag);
    tag.getTagName().setTagName("tag 2");

    System.out.println(new ObjectMapper().writeValueAsString(tag));

    mockMvc.perform(put(TAGS_ID_ROUTE, tag.getId()).contentType(MediaType.APPLICATION_JSON).content(new ObjectMapper().writeValueAsString(tag)))
        .andDo(print())
        .andExpect(status().isNoContent());

    Optional<Tag> foundTag = tagRepository.findById(tag.getId());
    assertTrue(foundTag.isPresent());
    assertEquals(tag, foundTag.get());
  }

  //PATCH /tags/{id}
  @Test
  void when_patch_tags_then_is_updated() throws Exception {
    Tag tag = new Tag(new TagName("tag 1"));
    tagRepository.save(tag);
    TagName tagName = new TagName("tag 2");
    tag.setTagName(tagName);

    mockMvc.perform(put(TAGS_ID_ROUTE, tag.getId()).contentType(MediaType.APPLICATION_JSON).content(new ObjectMapper().writeValueAsString(tagName)))
        .andDo(print())
        .andExpect(status().isNoContent());

    Optional<Tag> foundTag = tagRepository.findById(tag.getId());
    assertTrue(foundTag.isPresent());
    assertEquals(tag, foundTag.get());
  }
}
